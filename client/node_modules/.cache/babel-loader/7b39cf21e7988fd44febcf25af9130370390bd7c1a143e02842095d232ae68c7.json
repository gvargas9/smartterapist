{"ast":null,"code":"/**\n * TherapySession Model\n * \n * Provides methods for interacting with the therapy_sessions table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nexport class TherapySessionModel {\n  /**\n   * Get a therapy session by ID\n   * @param id - Session ID\n   * @returns The session or null if not found\n   */\n  static async getById(id) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').select('*').eq('id', id).single();\n    if (error) {\n      console.error('Error fetching therapy session:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Get therapy sessions by client ID\n   * @param clientId - Client ID\n   * @returns Array of sessions for the client\n   */\n  static async getByClientId(clientId) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').select('*').eq('client_id', clientId).order('scheduled_start', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error fetching sessions by client ID:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get therapy sessions by therapist ID\n   * @param therapistId - Therapist ID\n   * @returns Array of sessions for the therapist\n   */\n  static async getByTherapistId(therapistId) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').select('*').eq('therapist_id', therapistId).order('scheduled_start', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error fetching sessions by therapist ID:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get therapy sessions with client and therapist data\n   * @param filters - Optional filters to apply\n   * @returns Array of sessions with related data\n   */\n  static async getWithRelatedData(filters) {\n    let query = supabase.from('therapy_sessions').select(`\n        *,\n        clients!therapy_sessions_client_id_fkey (\n          *,\n          users:user_id (*)\n        ),\n        therapists!therapy_sessions_therapist_id_fkey (\n          *,\n          users:user_id (*)\n        )\n      `);\n\n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error fetching sessions with related data:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get upcoming sessions for a client or therapist\n   * @param userId - User ID\n   * @param role - User role ('client' or 'therapist')\n   * @returns Array of upcoming sessions\n   */\n  static async getUpcomingSessions(userId, role) {\n    // First, get the client or therapist ID based on the user ID\n    const {\n      data: profileData,\n      error: profileError\n    } = await supabase.from(role === 'client' ? 'clients' : 'therapists').select('id').eq('user_id', userId).single();\n    if (profileError || !profileData) {\n      console.error(`Error fetching ${role} profile:`, profileError);\n      return [];\n    }\n    const profileId = profileData.id;\n    const now = new Date().toISOString();\n\n    // Then get the upcoming sessions\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').select('*').eq(role === 'client' ? 'client_id' : 'therapist_id', profileId).gte('scheduled_start', now).order('scheduled_start', {\n      ascending: true\n    });\n    if (error) {\n      console.error('Error fetching upcoming sessions:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Create a new therapy session\n   * @param session - Session data to insert\n   * @returns The created session or null if there was an error\n   */\n  static async create(session) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').insert(session).select().single();\n    if (error) {\n      console.error('Error creating therapy session:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Update a therapy session\n   * @param id - Session ID\n   * @param updates - Session data to update\n   * @returns The updated session or null if there was an error\n   */\n  static async update(id, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').update(updates).eq('id', id).select().single();\n    if (error) {\n      console.error('Error updating therapy session:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Delete a therapy session\n   * @param id - Session ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id) {\n    const {\n      error\n    } = await supabase.from('therapy_sessions').delete().eq('id', id);\n    if (error) {\n      console.error('Error deleting therapy session:', error);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Update session status\n   * @param id - Session ID\n   * @param status - New status\n   * @returns The updated session or null if there was an error\n   */\n  static async updateStatus(id, status) {\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').update({\n      status\n    }).eq('id', id).select().single();\n    if (error) {\n      console.error('Error updating session status:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Start a session (update status and set actual_start)\n   * @param id - Session ID\n   * @returns The updated session or null if there was an error\n   */\n  static async startSession(id) {\n    const now = new Date().toISOString();\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').update({\n      status: 'in-progress',\n      actual_start: now\n    }).eq('id', id).select().single();\n    if (error) {\n      console.error('Error starting session:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * End a session (update status and set actual_end)\n   * @param id - Session ID\n   * @param notes - Optional session notes\n   * @returns The updated session or null if there was an error\n   */\n  static async endSession(id, notes) {\n    const now = new Date().toISOString();\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').update({\n      status: 'completed',\n      actual_end: now,\n      ...(notes && {\n        notes\n      })\n    }).eq('id', id).select().single();\n    if (error) {\n      console.error('Error ending session:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * List all therapy sessions with pagination\n   * @param page - Page number (starting from 0)\n   * @param limit - Number of items per page\n   * @returns Array of sessions\n   */\n  static async list(page = 0, limit = 10) {\n    const from = page * limit;\n    const to = from + limit - 1;\n    const {\n      data,\n      error\n    } = await supabase.from('therapy_sessions').select('*').range(from, to).order('scheduled_start', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error listing therapy sessions:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Count total number of therapy sessions\n   * @returns Total count of sessions\n   */\n  static async count() {\n    const {\n      count,\n      error\n    } = await supabase.from('therapy_sessions').select('*', {\n      count: 'exact',\n      head: true\n    });\n    if (error) {\n      console.error('Error counting therapy sessions:', error);\n      return 0;\n    }\n    return count || 0;\n  }\n}","map":{"version":3,"names":["supabase","TherapySessionModel","getById","id","data","error","from","select","eq","single","console","getByClientId","clientId","order","ascending","getByTherapistId","therapistId","getWithRelatedData","filters","query","Object","entries","forEach","key","value","getUpcomingSessions","userId","role","profileData","profileError","profileId","now","Date","toISOString","gte","create","session","insert","update","updates","delete","updateStatus","status","startSession","actual_start","endSession","notes","actual_end","list","page","limit","to","range","count","head"],"sources":["/Users/gio/development/smartterapist/client/src/models/TherapySessionModel.ts"],"sourcesContent":["/**\n * TherapySession Model\n * \n * Provides methods for interacting with the therapy_sessions table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nimport { TherapySession, InsertTables, UpdateTables } from '../types/supabase';\n\nexport class TherapySessionModel {\n  /**\n   * Get a therapy session by ID\n   * @param id - Session ID\n   * @returns The session or null if not found\n   */\n  static async getById(id: string): Promise<TherapySession | null> {\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .select('*')\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      console.error('Error fetching therapy session:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Get therapy sessions by client ID\n   * @param clientId - Client ID\n   * @returns Array of sessions for the client\n   */\n  static async getByClientId(clientId: string): Promise<TherapySession[]> {\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .select('*')\n      .eq('client_id', clientId)\n      .order('scheduled_start', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching sessions by client ID:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get therapy sessions by therapist ID\n   * @param therapistId - Therapist ID\n   * @returns Array of sessions for the therapist\n   */\n  static async getByTherapistId(therapistId: string): Promise<TherapySession[]> {\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .select('*')\n      .eq('therapist_id', therapistId)\n      .order('scheduled_start', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching sessions by therapist ID:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get therapy sessions with client and therapist data\n   * @param filters - Optional filters to apply\n   * @returns Array of sessions with related data\n   */\n  static async getWithRelatedData(filters?: Record<string, any>): Promise<any[]> {\n    let query = supabase\n      .from('therapy_sessions')\n      .select(`\n        *,\n        clients!therapy_sessions_client_id_fkey (\n          *,\n          users:user_id (*)\n        ),\n        therapists!therapy_sessions_therapist_id_fkey (\n          *,\n          users:user_id (*)\n        )\n      `);\n    \n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    \n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching sessions with related data:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get upcoming sessions for a client or therapist\n   * @param userId - User ID\n   * @param role - User role ('client' or 'therapist')\n   * @returns Array of upcoming sessions\n   */\n  static async getUpcomingSessions(userId: string, role: 'client' | 'therapist'): Promise<TherapySession[]> {\n    // First, get the client or therapist ID based on the user ID\n    const { data: profileData, error: profileError } = await supabase\n      .from(role === 'client' ? 'clients' : 'therapists')\n      .select('id')\n      .eq('user_id', userId)\n      .single();\n    \n    if (profileError || !profileData) {\n      console.error(`Error fetching ${role} profile:`, profileError);\n      return [];\n    }\n    \n    const profileId = profileData.id;\n    const now = new Date().toISOString();\n    \n    // Then get the upcoming sessions\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .select('*')\n      .eq(role === 'client' ? 'client_id' : 'therapist_id', profileId)\n      .gte('scheduled_start', now)\n      .order('scheduled_start', { ascending: true });\n    \n    if (error) {\n      console.error('Error fetching upcoming sessions:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Create a new therapy session\n   * @param session - Session data to insert\n   * @returns The created session or null if there was an error\n   */\n  static async create(session: InsertTables<'therapy_sessions'>): Promise<TherapySession | null> {\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .insert(session)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error creating therapy session:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Update a therapy session\n   * @param id - Session ID\n   * @param updates - Session data to update\n   * @returns The updated session or null if there was an error\n   */\n  static async update(id: string, updates: UpdateTables<'therapy_sessions'>): Promise<TherapySession | null> {\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating therapy session:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Delete a therapy session\n   * @param id - Session ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id: string): Promise<boolean> {\n    const { error } = await supabase\n      .from('therapy_sessions')\n      .delete()\n      .eq('id', id);\n    \n    if (error) {\n      console.error('Error deleting therapy session:', error);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Update session status\n   * @param id - Session ID\n   * @param status - New status\n   * @returns The updated session or null if there was an error\n   */\n  static async updateStatus(id: string, status: 'scheduled' | 'in-progress' | 'completed' | 'cancelled'): Promise<TherapySession | null> {\n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .update({ status })\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating session status:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Start a session (update status and set actual_start)\n   * @param id - Session ID\n   * @returns The updated session or null if there was an error\n   */\n  static async startSession(id: string): Promise<TherapySession | null> {\n    const now = new Date().toISOString();\n    \n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .update({\n        status: 'in-progress',\n        actual_start: now\n      })\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error starting session:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * End a session (update status and set actual_end)\n   * @param id - Session ID\n   * @param notes - Optional session notes\n   * @returns The updated session or null if there was an error\n   */\n  static async endSession(id: string, notes?: string): Promise<TherapySession | null> {\n    const now = new Date().toISOString();\n    \n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .update({\n        status: 'completed',\n        actual_end: now,\n        ...(notes && { notes })\n      })\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error ending session:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * List all therapy sessions with pagination\n   * @param page - Page number (starting from 0)\n   * @param limit - Number of items per page\n   * @returns Array of sessions\n   */\n  static async list(page: number = 0, limit: number = 10): Promise<TherapySession[]> {\n    const from = page * limit;\n    const to = from + limit - 1;\n    \n    const { data, error } = await supabase\n      .from('therapy_sessions')\n      .select('*')\n      .range(from, to)\n      .order('scheduled_start', { ascending: false });\n    \n    if (error) {\n      console.error('Error listing therapy sessions:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Count total number of therapy sessions\n   * @returns Total count of sessions\n   */\n  static async count(): Promise<number> {\n    const { count, error } = await supabase\n      .from('therapy_sessions')\n      .select('*', { count: 'exact', head: true });\n    \n    if (error) {\n      console.error('Error counting therapy sessions:', error);\n      return 0;\n    }\n    \n    return count || 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}