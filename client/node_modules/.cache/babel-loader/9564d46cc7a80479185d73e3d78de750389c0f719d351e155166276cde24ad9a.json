{"ast":null,"code":"/**\n * Message Model\n * \n * Provides methods for interacting with the messages table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nexport class MessageModel {\n  /**\n   * Get a message by ID\n   * @param id - Message ID\n   * @returns The message or null if not found\n   */\n  static async getById(id) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').select('*').eq('id', id).single();\n    if (error) {\n      console.error('Error fetching message:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Get messages sent by a user\n   * @param userId - User ID\n   * @returns Array of messages sent by the user\n   */\n  static async getSentByUser(userId) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').select('*').eq('sender_id', userId).order('created_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error fetching sent messages:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get messages received by a user\n   * @param userId - User ID\n   * @returns Array of messages received by the user\n   */\n  static async getReceivedByUser(userId) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').select('*').eq('recipient_id', userId).order('created_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error fetching received messages:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get conversation between two users\n   * @param userId1 - First user ID\n   * @param userId2 - Second user ID\n   * @returns Array of messages between the two users\n   */\n  static async getConversation(userId1, userId2) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').select('*').or(`and(sender_id.eq.${userId1},recipient_id.eq.${userId2}),and(sender_id.eq.${userId2},recipient_id.eq.${userId1})`).order('created_at', {\n      ascending: true\n    });\n    if (error) {\n      console.error('Error fetching conversation:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get messages with sender and recipient data\n   * @param filters - Optional filters to apply\n   * @returns Array of messages with related user data\n   */\n  static async getWithUserData(filters) {\n    let query = supabase.from('messages').select(`\n        *,\n        sender:sender_id (id, first_name, last_name, email),\n        recipient:recipient_id (id, first_name, last_name, email)\n      `);\n\n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error fetching messages with user data:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Create a new message\n   * @param message - Message data to insert\n   * @returns The created message or null if there was an error\n   */\n  static async create(message) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').insert(message).select().single();\n    if (error) {\n      console.error('Error creating message:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Update a message\n   * @param id - Message ID\n   * @param updates - Message data to update\n   * @returns The updated message or null if there was an error\n   */\n  static async update(id, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').update(updates).eq('id', id).select().single();\n    if (error) {\n      console.error('Error updating message:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Delete a message\n   * @param id - Message ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id) {\n    const {\n      error\n    } = await supabase.from('messages').delete().eq('id', id);\n    if (error) {\n      console.error('Error deleting message:', error);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Mark a message as read\n   * @param id - Message ID\n   * @returns The updated message or null if there was an error\n   */\n  static async markAsRead(id) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').update({\n      read: true\n    }).eq('id', id).select().single();\n    if (error) {\n      console.error('Error marking message as read:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Mark all messages as read for a recipient\n   * @param recipientId - Recipient user ID\n   * @returns Number of messages marked as read\n   */\n  static async markAllAsRead(recipientId) {\n    const {\n      data,\n      error\n    } = await supabase.from('messages').update({\n      read: true\n    }).eq('recipient_id', recipientId).eq('read', false).select();\n    if (error) {\n      console.error('Error marking all messages as read:', error);\n      return 0;\n    }\n    return (data === null || data === void 0 ? void 0 : data.length) || 0;\n  }\n\n  /**\n   * Count unread messages for a user\n   * @param userId - User ID\n   * @returns Count of unread messages\n   */\n  static async countUnread(userId) {\n    const {\n      count,\n      error\n    } = await supabase.from('messages').select('*', {\n      count: 'exact',\n      head: true\n    }).eq('recipient_id', userId).eq('read', false);\n    if (error) {\n      console.error('Error counting unread messages:', error);\n      return 0;\n    }\n    return count || 0;\n  }\n\n  /**\n   * Subscribe to new messages for a user\n   * @param userId - User ID\n   * @param callback - Callback function to handle new messages\n   * @returns Subscription object with unsubscribe method\n   */\n  static subscribeToNewMessages(userId, callback) {\n    const subscription = supabase.channel('public:messages').on('postgres_changes', {\n      event: 'INSERT',\n      schema: 'public',\n      table: 'messages',\n      filter: `recipient_id=eq.${userId}`\n    }, payload => {\n      callback(payload);\n    }).subscribe();\n    return {\n      unsubscribe: () => {\n        subscription.unsubscribe();\n      }\n    };\n  }\n}","map":{"version":3,"names":["supabase","MessageModel","getById","id","data","error","from","select","eq","single","console","getSentByUser","userId","order","ascending","getReceivedByUser","getConversation","userId1","userId2","or","getWithUserData","filters","query","Object","entries","forEach","key","value","create","message","insert","update","updates","delete","markAsRead","read","markAllAsRead","recipientId","length","countUnread","count","head","subscribeToNewMessages","callback","subscription","channel","on","event","schema","table","filter","payload","subscribe","unsubscribe"],"sources":["/Users/gio/development/smartterapist/client/src/models/MessageModel.ts"],"sourcesContent":["/**\n * Message Model\n * \n * Provides methods for interacting with the messages table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nimport { Message, InsertTables, UpdateTables } from '../types/supabase';\n\nexport class MessageModel {\n  /**\n   * Get a message by ID\n   * @param id - Message ID\n   * @returns The message or null if not found\n   */\n  static async getById(id: string): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      console.error('Error fetching message:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Get messages sent by a user\n   * @param userId - User ID\n   * @returns Array of messages sent by the user\n   */\n  static async getSentByUser(userId: string): Promise<Message[]> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .eq('sender_id', userId)\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching sent messages:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get messages received by a user\n   * @param userId - User ID\n   * @returns Array of messages received by the user\n   */\n  static async getReceivedByUser(userId: string): Promise<Message[]> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .eq('recipient_id', userId)\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching received messages:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get conversation between two users\n   * @param userId1 - First user ID\n   * @param userId2 - Second user ID\n   * @returns Array of messages between the two users\n   */\n  static async getConversation(userId1: string, userId2: string): Promise<Message[]> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .or(`and(sender_id.eq.${userId1},recipient_id.eq.${userId2}),and(sender_id.eq.${userId2},recipient_id.eq.${userId1})`)\n      .order('created_at', { ascending: true });\n    \n    if (error) {\n      console.error('Error fetching conversation:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get messages with sender and recipient data\n   * @param filters - Optional filters to apply\n   * @returns Array of messages with related user data\n   */\n  static async getWithUserData(filters?: Record<string, any>): Promise<any[]> {\n    let query = supabase\n      .from('messages')\n      .select(`\n        *,\n        sender:sender_id (id, first_name, last_name, email),\n        recipient:recipient_id (id, first_name, last_name, email)\n      `);\n    \n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    \n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching messages with user data:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Create a new message\n   * @param message - Message data to insert\n   * @returns The created message or null if there was an error\n   */\n  static async create(message: InsertTables<'messages'>): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .insert(message)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error creating message:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Update a message\n   * @param id - Message ID\n   * @param updates - Message data to update\n   * @returns The updated message or null if there was an error\n   */\n  static async update(id: string, updates: UpdateTables<'messages'>): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating message:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Delete a message\n   * @param id - Message ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id: string): Promise<boolean> {\n    const { error } = await supabase\n      .from('messages')\n      .delete()\n      .eq('id', id);\n    \n    if (error) {\n      console.error('Error deleting message:', error);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Mark a message as read\n   * @param id - Message ID\n   * @returns The updated message or null if there was an error\n   */\n  static async markAsRead(id: string): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .update({ read: true })\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error marking message as read:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Mark all messages as read for a recipient\n   * @param recipientId - Recipient user ID\n   * @returns Number of messages marked as read\n   */\n  static async markAllAsRead(recipientId: string): Promise<number> {\n    const { data, error } = await supabase\n      .from('messages')\n      .update({ read: true })\n      .eq('recipient_id', recipientId)\n      .eq('read', false)\n      .select();\n    \n    if (error) {\n      console.error('Error marking all messages as read:', error);\n      return 0;\n    }\n    \n    return data?.length || 0;\n  }\n\n  /**\n   * Count unread messages for a user\n   * @param userId - User ID\n   * @returns Count of unread messages\n   */\n  static async countUnread(userId: string): Promise<number> {\n    const { count, error } = await supabase\n      .from('messages')\n      .select('*', { count: 'exact', head: true })\n      .eq('recipient_id', userId)\n      .eq('read', false);\n    \n    if (error) {\n      console.error('Error counting unread messages:', error);\n      return 0;\n    }\n    \n    return count || 0;\n  }\n\n  /**\n   * Subscribe to new messages for a user\n   * @param userId - User ID\n   * @param callback - Callback function to handle new messages\n   * @returns Subscription object with unsubscribe method\n   */\n  static subscribeToNewMessages(userId: string, callback: (payload: any) => void): { unsubscribe: () => void } {\n    const subscription = supabase\n      .channel('public:messages')\n      .on('postgres_changes', {\n        event: 'INSERT',\n        schema: 'public',\n        table: 'messages',\n        filter: `recipient_id=eq.${userId}`\n      }, (payload) => {\n        callback(payload);\n      })\n      .subscribe();\n    \n    return {\n      unsubscribe: () => {\n        subscription.unsubscribe();\n      }\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}