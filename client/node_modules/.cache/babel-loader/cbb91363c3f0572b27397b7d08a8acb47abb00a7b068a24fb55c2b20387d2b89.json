{"ast":null,"code":"/**\n * BehaviorRecord Model\n * \n * Provides methods for interacting with the behavior_records table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nexport class BehaviorRecordModel {\n  /**\n   * Get a behavior record by ID\n   * @param id - Behavior record ID\n   * @returns The behavior record or null if not found\n   */\n  static async getById(id) {\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').select('*').eq('id', id).single();\n    if (error) {\n      console.error('Error fetching behavior record:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Get behavior records by client ID\n   * @param clientId - Client ID\n   * @returns Array of behavior records for the client\n   */\n  static async getByClientId(clientId) {\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').select('*').eq('client_id', clientId).order('recorded_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error fetching behavior records by client ID:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get behavior records by behavior type\n   * @param clientId - Client ID\n   * @param behaviorType - Behavior type\n   * @returns Array of behavior records of the specified type\n   */\n  static async getByBehaviorType(clientId, behaviorType) {\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').select('*').eq('client_id', clientId).eq('behavior_type', behaviorType).order('recorded_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error fetching behavior records by type:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get behavior records within a date range\n   * @param clientId - Client ID\n   * @param startDate - Start date (ISO string)\n   * @param endDate - End date (ISO string)\n   * @returns Array of behavior records within the date range\n   */\n  static async getByDateRange(clientId, startDate, endDate) {\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').select('*').eq('client_id', clientId).gte('recorded_at', startDate).lte('recorded_at', endDate).order('recorded_at', {\n      ascending: true\n    });\n    if (error) {\n      console.error('Error fetching behavior records by date range:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Get behavior records with client data\n   * @param filters - Optional filters to apply\n   * @returns Array of behavior records with client data\n   */\n  static async getWithClientData(filters) {\n    let query = supabase.from('behavior_records').select(`\n        *,\n        clients!behavior_records_client_id_fkey (\n          *,\n          users:user_id (*)\n        )\n      `);\n\n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error fetching behavior records with client data:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Create a new behavior record\n   * @param record - Behavior record data to insert\n   * @returns The created behavior record or null if there was an error\n   */\n  static async create(record) {\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').insert(record).select().single();\n    if (error) {\n      console.error('Error creating behavior record:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Update a behavior record\n   * @param id - Behavior record ID\n   * @param updates - Behavior record data to update\n   * @returns The updated behavior record or null if there was an error\n   */\n  static async update(id, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').update(updates).eq('id', id).select().single();\n    if (error) {\n      console.error('Error updating behavior record:', error);\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Delete a behavior record\n   * @param id - Behavior record ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id) {\n    const {\n      error\n    } = await supabase.from('behavior_records').delete().eq('id', id);\n    if (error) {\n      console.error('Error deleting behavior record:', error);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Get behavior statistics for a client\n   * @param clientId - Client ID\n   * @param days - Number of days to include in statistics (default: 30)\n   * @returns Statistics about the client's behavior records\n   */\n  static async getStatistics(clientId, days = 30) {\n    // Calculate the start date (X days ago)\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n    const startDateStr = startDate.toISOString();\n\n    // Get all behavior records in the date range\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').select('*').eq('client_id', clientId).gte('recorded_at', startDateStr).order('recorded_at', {\n      ascending: true\n    });\n    if (error) {\n      console.error('Error fetching behavior statistics:', error);\n      return {\n        totalRecords: 0,\n        behaviorTypes: {},\n        averageSeverity: 0,\n        severityTrend: []\n      };\n    }\n    const records = data || [];\n\n    // Calculate statistics\n    const behaviorTypes = {};\n    let totalSeverity = 0;\n    let severityCount = 0;\n\n    // Group records by date for trend analysis\n    const recordsByDate = {};\n    records.forEach(record => {\n      // Count behavior types\n      behaviorTypes[record.behavior_type] = (behaviorTypes[record.behavior_type] || 0) + 1;\n\n      // Sum severity for average calculation\n      if (record.severity !== null) {\n        totalSeverity += record.severity;\n        severityCount++;\n      }\n\n      // Group by date for trend\n      const dateStr = record.recorded_at.split('T')[0]; // Get just the date part\n      if (!recordsByDate[dateStr]) {\n        recordsByDate[dateStr] = [];\n      }\n      recordsByDate[dateStr].push(record);\n    });\n\n    // Calculate severity trend (average severity per day)\n    const severityTrend = Object.entries(recordsByDate).map(([date, dayRecords]) => {\n      const dayTotalSeverity = dayRecords.reduce((sum, record) => {\n        return sum + (record.severity || 0);\n      }, 0);\n      const dayAverageSeverity = dayRecords.length > 0 ? dayTotalSeverity / dayRecords.length : 0;\n      return {\n        date,\n        averageSeverity: dayAverageSeverity,\n        count: dayRecords.length\n      };\n    });\n    return {\n      totalRecords: records.length,\n      behaviorTypes,\n      averageSeverity: severityCount > 0 ? totalSeverity / severityCount : 0,\n      severityTrend\n    };\n  }\n\n  /**\n   * List all behavior records with pagination\n   * @param page - Page number (starting from 0)\n   * @param limit - Number of items per page\n   * @returns Array of behavior records\n   */\n  static async list(page = 0, limit = 10) {\n    const from = page * limit;\n    const to = from + limit - 1;\n    const {\n      data,\n      error\n    } = await supabase.from('behavior_records').select('*').range(from, to).order('recorded_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error listing behavior records:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Count total number of behavior records\n   * @returns Total count of behavior records\n   */\n  static async count() {\n    const {\n      count,\n      error\n    } = await supabase.from('behavior_records').select('*', {\n      count: 'exact',\n      head: true\n    });\n    if (error) {\n      console.error('Error counting behavior records:', error);\n      return 0;\n    }\n    return count || 0;\n  }\n}","map":{"version":3,"names":["supabase","BehaviorRecordModel","getById","id","data","error","from","select","eq","single","console","getByClientId","clientId","order","ascending","getByBehaviorType","behaviorType","getByDateRange","startDate","endDate","gte","lte","getWithClientData","filters","query","Object","entries","forEach","key","value","create","record","insert","update","updates","delete","getStatistics","days","Date","setDate","getDate","startDateStr","toISOString","totalRecords","behaviorTypes","averageSeverity","severityTrend","records","totalSeverity","severityCount","recordsByDate","behavior_type","severity","dateStr","recorded_at","split","push","map","date","dayRecords","dayTotalSeverity","reduce","sum","dayAverageSeverity","length","count","list","page","limit","to","range","head"],"sources":["/Users/gio/development/smartterapist/client/src/models/BehaviorRecordModel.ts"],"sourcesContent":["/**\n * BehaviorRecord Model\n * \n * Provides methods for interacting with the behavior_records table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nimport { BehaviorRecord, InsertTables, UpdateTables } from '../types/supabase';\n\nexport class BehaviorRecordModel {\n  /**\n   * Get a behavior record by ID\n   * @param id - Behavior record ID\n   * @returns The behavior record or null if not found\n   */\n  static async getById(id: string): Promise<BehaviorRecord | null> {\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .select('*')\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      console.error('Error fetching behavior record:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Get behavior records by client ID\n   * @param clientId - Client ID\n   * @returns Array of behavior records for the client\n   */\n  static async getByClientId(clientId: string): Promise<BehaviorRecord[]> {\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .select('*')\n      .eq('client_id', clientId)\n      .order('recorded_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching behavior records by client ID:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get behavior records by behavior type\n   * @param clientId - Client ID\n   * @param behaviorType - Behavior type\n   * @returns Array of behavior records of the specified type\n   */\n  static async getByBehaviorType(clientId: string, behaviorType: string): Promise<BehaviorRecord[]> {\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .select('*')\n      .eq('client_id', clientId)\n      .eq('behavior_type', behaviorType)\n      .order('recorded_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching behavior records by type:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get behavior records within a date range\n   * @param clientId - Client ID\n   * @param startDate - Start date (ISO string)\n   * @param endDate - End date (ISO string)\n   * @returns Array of behavior records within the date range\n   */\n  static async getByDateRange(clientId: string, startDate: string, endDate: string): Promise<BehaviorRecord[]> {\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .select('*')\n      .eq('client_id', clientId)\n      .gte('recorded_at', startDate)\n      .lte('recorded_at', endDate)\n      .order('recorded_at', { ascending: true });\n    \n    if (error) {\n      console.error('Error fetching behavior records by date range:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get behavior records with client data\n   * @param filters - Optional filters to apply\n   * @returns Array of behavior records with client data\n   */\n  static async getWithClientData(filters?: Record<string, any>): Promise<any[]> {\n    let query = supabase\n      .from('behavior_records')\n      .select(`\n        *,\n        clients!behavior_records_client_id_fkey (\n          *,\n          users:user_id (*)\n        )\n      `);\n    \n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    \n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching behavior records with client data:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Create a new behavior record\n   * @param record - Behavior record data to insert\n   * @returns The created behavior record or null if there was an error\n   */\n  static async create(record: InsertTables<'behavior_records'>): Promise<BehaviorRecord | null> {\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .insert(record)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error creating behavior record:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Update a behavior record\n   * @param id - Behavior record ID\n   * @param updates - Behavior record data to update\n   * @returns The updated behavior record or null if there was an error\n   */\n  static async update(id: string, updates: UpdateTables<'behavior_records'>): Promise<BehaviorRecord | null> {\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating behavior record:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Delete a behavior record\n   * @param id - Behavior record ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id: string): Promise<boolean> {\n    const { error } = await supabase\n      .from('behavior_records')\n      .delete()\n      .eq('id', id);\n    \n    if (error) {\n      console.error('Error deleting behavior record:', error);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Get behavior statistics for a client\n   * @param clientId - Client ID\n   * @param days - Number of days to include in statistics (default: 30)\n   * @returns Statistics about the client's behavior records\n   */\n  static async getStatistics(clientId: string, days: number = 30): Promise<any> {\n    // Calculate the start date (X days ago)\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n    const startDateStr = startDate.toISOString();\n    \n    // Get all behavior records in the date range\n    const { data, error } = await supabase\n      .from('behavior_records')\n      .select('*')\n      .eq('client_id', clientId)\n      .gte('recorded_at', startDateStr)\n      .order('recorded_at', { ascending: true });\n    \n    if (error) {\n      console.error('Error fetching behavior statistics:', error);\n      return {\n        totalRecords: 0,\n        behaviorTypes: {},\n        averageSeverity: 0,\n        severityTrend: []\n      };\n    }\n    \n    const records = data || [];\n    \n    // Calculate statistics\n    const behaviorTypes: Record<string, number> = {};\n    let totalSeverity = 0;\n    let severityCount = 0;\n    \n    // Group records by date for trend analysis\n    const recordsByDate: Record<string, any[]> = {};\n    \n    records.forEach(record => {\n      // Count behavior types\n      behaviorTypes[record.behavior_type] = (behaviorTypes[record.behavior_type] || 0) + 1;\n      \n      // Sum severity for average calculation\n      if (record.severity !== null) {\n        totalSeverity += record.severity;\n        severityCount++;\n      }\n      \n      // Group by date for trend\n      const dateStr = record.recorded_at.split('T')[0]; // Get just the date part\n      if (!recordsByDate[dateStr]) {\n        recordsByDate[dateStr] = [];\n      }\n      recordsByDate[dateStr].push(record);\n    });\n    \n    // Calculate severity trend (average severity per day)\n    const severityTrend = Object.entries(recordsByDate).map(([date, dayRecords]) => {\n      const dayTotalSeverity = dayRecords.reduce((sum, record) => {\n        return sum + (record.severity || 0);\n      }, 0);\n      const dayAverageSeverity = dayRecords.length > 0 ? dayTotalSeverity / dayRecords.length : 0;\n      \n      return {\n        date,\n        averageSeverity: dayAverageSeverity,\n        count: dayRecords.length\n      };\n    });\n    \n    return {\n      totalRecords: records.length,\n      behaviorTypes,\n      averageSeverity: severityCount > 0 ? totalSeverity / severityCount : 0,\n      severityTrend\n    };\n  }\n\n  /**\n   * List all behavior records with pagination\n   * @param page - Page number (starting from 0)\n   * @param limit - Number of items per page\n   * @returns Array of behavior records\n   */\n  static async list(page: number = 0, limit: number = 10): Promise<BehaviorRecord[]> {\n    const from = page * limit;\n    const to = from + limit - 1;\n    \n    const { data, error } = await supabase\n      .from('behavior_records')\n      .select('*')\n      .range(from, to)\n      .order('recorded_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error listing behavior records:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Count total number of behavior records\n   * @returns Total count of behavior records\n   */\n  static async count(): Promise<number> {\n    const { count, error } = await supabase\n      .from('behavior_records')\n      .select('*', { count: 'exact', head: true });\n    \n    if (error) {\n      console.error('Error counting behavior records:', error);\n      return 0;\n    }\n    \n    return count || 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}