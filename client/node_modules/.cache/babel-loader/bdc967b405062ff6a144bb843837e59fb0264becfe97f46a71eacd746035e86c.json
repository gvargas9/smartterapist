{"ast":null,"code":"/**\n * Message Model\n * \n * Provides methods for interacting with the messages table in Supabase.\n */import{supabase}from'../services/supabaseClient';export class MessageModel{/**\n   * Get a message by ID\n   * @param id - Message ID\n   * @returns The message or null if not found\n   */static async getById(id){const{data,error}=await supabase.from('messages').select('*').eq('id',id).single();if(error){console.error('Error fetching message:',error);return null;}return data;}/**\n   * Get messages sent by a user\n   * @param userId - User ID\n   * @returns Array of messages sent by the user\n   */static async getSentByUser(userId){const{data,error}=await supabase.from('messages').select('*').eq('sender_id',userId).order('created_at',{ascending:false});if(error){console.error('Error fetching sent messages:',error);return[];}return data||[];}/**\n   * Get messages received by a user\n   * @param userId - User ID\n   * @returns Array of messages received by the user\n   */static async getReceivedByUser(userId){const{data,error}=await supabase.from('messages').select('*').eq('recipient_id',userId).order('created_at',{ascending:false});if(error){console.error('Error fetching received messages:',error);return[];}return data||[];}/**\n   * Get conversation between two users\n   * @param userId1 - First user ID\n   * @param userId2 - Second user ID\n   * @returns Array of messages between the two users\n   */static async getConversation(userId1,userId2){const{data,error}=await supabase.from('messages').select('*').or(`and(sender_id.eq.${userId1},recipient_id.eq.${userId2}),and(sender_id.eq.${userId2},recipient_id.eq.${userId1})`).order('created_at',{ascending:true});if(error){console.error('Error fetching conversation:',error);return[];}return data||[];}/**\n   * Get messages with sender and recipient data\n   * @param filters - Optional filters to apply\n   * @returns Array of messages with related user data\n   */static async getWithUserData(filters){let query=supabase.from('messages').select(`\n        *,\n        sender:sender_id (id, first_name, last_name, email),\n        recipient:recipient_id (id, first_name, last_name, email)\n      `);// Apply filters if provided\nif(filters){Object.entries(filters).forEach(_ref=>{let[key,value]=_ref;query=query.eq(key,value);});}const{data,error}=await query;if(error){console.error('Error fetching messages with user data:',error);return[];}return data||[];}/**\n   * Create a new message\n   * @param message - Message data to insert\n   * @returns The created message or null if there was an error\n   */static async create(message){const{data,error}=await supabase.from('messages').insert(message).select().single();if(error){console.error('Error creating message:',error);return null;}return data;}/**\n   * Update a message\n   * @param id - Message ID\n   * @param updates - Message data to update\n   * @returns The updated message or null if there was an error\n   */static async update(id,updates){const{data,error}=await supabase.from('messages').update(updates).eq('id',id).select().single();if(error){console.error('Error updating message:',error);return null;}return data;}/**\n   * Delete a message\n   * @param id - Message ID\n   * @returns True if successful, false otherwise\n   */static async delete(id){const{error}=await supabase.from('messages').delete().eq('id',id);if(error){console.error('Error deleting message:',error);return false;}return true;}/**\n   * Mark a message as read\n   * @param id - Message ID\n   * @returns The updated message or null if there was an error\n   */static async markAsRead(id){const{data,error}=await supabase.from('messages').update({read:true}).eq('id',id).select().single();if(error){console.error('Error marking message as read:',error);return null;}return data;}/**\n   * Mark all messages as read for a recipient\n   * @param recipientId - Recipient user ID\n   * @returns Number of messages marked as read\n   */static async markAllAsRead(recipientId){const{data,error}=await supabase.from('messages').update({read:true}).eq('recipient_id',recipientId).eq('read',false).select();if(error){console.error('Error marking all messages as read:',error);return 0;}return(data===null||data===void 0?void 0:data.length)||0;}/**\n   * Count unread messages for a user\n   * @param userId - User ID\n   * @returns Count of unread messages\n   */static async countUnread(userId){const{count,error}=await supabase.from('messages').select('*',{count:'exact',head:true}).eq('recipient_id',userId).eq('read',false);if(error){console.error('Error counting unread messages:',error);return 0;}return count||0;}/**\n   * Subscribe to new messages for a user\n   * @param userId - User ID\n   * @param callback - Callback function to handle new messages\n   * @returns Subscription object with unsubscribe method\n   */static subscribeToNewMessages(userId,callback){const subscription=supabase.channel('public:messages').on('postgres_changes',{event:'INSERT',schema:'public',table:'messages',filter:`recipient_id=eq.${userId}`},payload=>{callback(payload);}).subscribe();return{unsubscribe:()=>{subscription.unsubscribe();}};}}","map":{"version":3,"names":["supabase","MessageModel","getById","id","data","error","from","select","eq","single","console","getSentByUser","userId","order","ascending","getReceivedByUser","getConversation","userId1","userId2","or","getWithUserData","filters","query","Object","entries","forEach","_ref","key","value","create","message","insert","update","updates","delete","markAsRead","read","markAllAsRead","recipientId","length","countUnread","count","head","subscribeToNewMessages","callback","subscription","channel","on","event","schema","table","filter","payload","subscribe","unsubscribe"],"sources":["/Users/gio/development/smartterapist/client/src/models/MessageModel.ts"],"sourcesContent":["/**\n * Message Model\n * \n * Provides methods for interacting with the messages table in Supabase.\n */\n\nimport { supabase } from '../services/supabaseClient';\nimport { Message, InsertTables, UpdateTables } from '../types/supabase';\n\nexport class MessageModel {\n  /**\n   * Get a message by ID\n   * @param id - Message ID\n   * @returns The message or null if not found\n   */\n  static async getById(id: string): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      console.error('Error fetching message:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Get messages sent by a user\n   * @param userId - User ID\n   * @returns Array of messages sent by the user\n   */\n  static async getSentByUser(userId: string): Promise<Message[]> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .eq('sender_id', userId)\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching sent messages:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get messages received by a user\n   * @param userId - User ID\n   * @returns Array of messages received by the user\n   */\n  static async getReceivedByUser(userId: string): Promise<Message[]> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .eq('recipient_id', userId)\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      console.error('Error fetching received messages:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get conversation between two users\n   * @param userId1 - First user ID\n   * @param userId2 - Second user ID\n   * @returns Array of messages between the two users\n   */\n  static async getConversation(userId1: string, userId2: string): Promise<Message[]> {\n    const { data, error } = await supabase\n      .from('messages')\n      .select('*')\n      .or(`and(sender_id.eq.${userId1},recipient_id.eq.${userId2}),and(sender_id.eq.${userId2},recipient_id.eq.${userId1})`)\n      .order('created_at', { ascending: true });\n    \n    if (error) {\n      console.error('Error fetching conversation:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Get messages with sender and recipient data\n   * @param filters - Optional filters to apply\n   * @returns Array of messages with related user data\n   */\n  static async getWithUserData(filters?: Record<string, any>): Promise<any[]> {\n    let query = supabase\n      .from('messages')\n      .select(`\n        *,\n        sender:sender_id (id, first_name, last_name, email),\n        recipient:recipient_id (id, first_name, last_name, email)\n      `);\n    \n    // Apply filters if provided\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        query = query.eq(key, value);\n      });\n    }\n    \n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching messages with user data:', error);\n      return [];\n    }\n    \n    return data || [];\n  }\n\n  /**\n   * Create a new message\n   * @param message - Message data to insert\n   * @returns The created message or null if there was an error\n   */\n  static async create(message: InsertTables<'messages'>): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .insert(message)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error creating message:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Update a message\n   * @param id - Message ID\n   * @param updates - Message data to update\n   * @returns The updated message or null if there was an error\n   */\n  static async update(id: string, updates: UpdateTables<'messages'>): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating message:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Delete a message\n   * @param id - Message ID\n   * @returns True if successful, false otherwise\n   */\n  static async delete(id: string): Promise<boolean> {\n    const { error } = await supabase\n      .from('messages')\n      .delete()\n      .eq('id', id);\n    \n    if (error) {\n      console.error('Error deleting message:', error);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Mark a message as read\n   * @param id - Message ID\n   * @returns The updated message or null if there was an error\n   */\n  static async markAsRead(id: string): Promise<Message | null> {\n    const { data, error } = await supabase\n      .from('messages')\n      .update({ read: true })\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error marking message as read:', error);\n      return null;\n    }\n    \n    return data;\n  }\n\n  /**\n   * Mark all messages as read for a recipient\n   * @param recipientId - Recipient user ID\n   * @returns Number of messages marked as read\n   */\n  static async markAllAsRead(recipientId: string): Promise<number> {\n    const { data, error } = await supabase\n      .from('messages')\n      .update({ read: true })\n      .eq('recipient_id', recipientId)\n      .eq('read', false)\n      .select();\n    \n    if (error) {\n      console.error('Error marking all messages as read:', error);\n      return 0;\n    }\n    \n    return data?.length || 0;\n  }\n\n  /**\n   * Count unread messages for a user\n   * @param userId - User ID\n   * @returns Count of unread messages\n   */\n  static async countUnread(userId: string): Promise<number> {\n    const { count, error } = await supabase\n      .from('messages')\n      .select('*', { count: 'exact', head: true })\n      .eq('recipient_id', userId)\n      .eq('read', false);\n    \n    if (error) {\n      console.error('Error counting unread messages:', error);\n      return 0;\n    }\n    \n    return count || 0;\n  }\n\n  /**\n   * Subscribe to new messages for a user\n   * @param userId - User ID\n   * @param callback - Callback function to handle new messages\n   * @returns Subscription object with unsubscribe method\n   */\n  static subscribeToNewMessages(userId: string, callback: (payload: any) => void): { unsubscribe: () => void } {\n    const subscription = supabase\n      .channel('public:messages')\n      .on('postgres_changes', {\n        event: 'INSERT',\n        schema: 'public',\n        table: 'messages',\n        filter: `recipient_id=eq.${userId}`\n      }, (payload) => {\n        callback(payload);\n      })\n      .subscribe();\n    \n    return {\n      unsubscribe: () => {\n        subscription.unsubscribe();\n      }\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}