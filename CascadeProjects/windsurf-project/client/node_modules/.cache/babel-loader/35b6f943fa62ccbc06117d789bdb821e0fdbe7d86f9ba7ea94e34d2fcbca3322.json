{"ast":null,"code":"import{supabase}from'./supabaseClient';/**\n * Service for handling user-related functionality\n */export const userService={/**\n   * Get user profile data\n   * @param {string} userId - The user's ID\n   * @returns {Promise<Object>} - The user profile data\n   */async getUserProfile(userId){try{const{data,error}=await supabase.from('users').select('*').eq('id',userId).single();if(error)throw error;return data;}catch(error){console.error('Error fetching user profile:',error);throw error;}},/**\n   * Get client-specific data\n   * @param {string} userId - The client's user ID\n   * @returns {Promise<Object>} - The client data\n   */async getClientData(userId){try{const{data,error}=await supabase.from('clients').select('*').eq('user_id',userId).single();if(error)throw error;return data;}catch(error){console.error('Error fetching client data:',error);throw error;}},/**\n   * Get therapist-specific data\n   * @param {string} userId - The therapist's user ID\n   * @returns {Promise<Object>} - The therapist data\n   */async getTherapistData(userId){try{const{data,error}=await supabase.from('therapists').select('*').eq('user_id',userId).single();if(error)throw error;return data;}catch(error){console.error('Error fetching therapist data:',error);throw error;}},/**\n   * Get a list of clients for a therapist\n   * @param {string} therapistId - The therapist's user ID\n   * @returns {Promise<Array>} - Array of client data\n   */async getTherapistClients(therapistId){try{const{data,error}=await supabase.from('sessions').select('client_id').eq('therapist_id',therapistId).order('start_time',{ascending:false});if(error)throw error;// Get unique client IDs\nconst clientIds=[...new Set(data.map(session=>session.client_id))];// Get client profiles\nconst{data:clients,error:clientsError}=await supabase.from('users').select('*, clients(*)').in('id',clientIds);if(clientsError)throw clientsError;return clients;}catch(error){console.error('Error fetching therapist clients:',error);throw error;}},/**\n   * Get upcoming sessions for a user\n   * @param {string} userId - The user's ID\n   * @param {string} role - The user's role ('client' or 'therapist')\n   * @returns {Promise<Array>} - Array of upcoming sessions\n   */async getUpcomingSessions(userId,role){try{const query=supabase.from('sessions').select(`\n          *,\n          clients:users!sessions_client_id_fkey(*),\n          therapists:users!sessions_therapist_id_fkey(*)\n        `).gt('start_time',new Date().toISOString()).order('start_time',{ascending:true});// Filter by role\nif(role==='client'){query.eq('client_id',userId);}else if(role==='therapist'){query.eq('therapist_id',userId);}const{data,error}=await query;if(error)throw error;return data||[];}catch(error){console.error('Error fetching upcoming sessions:',error);throw error;}},/**\n   * Get recent conversations for a user\n   * @param {string} userId - The user's ID\n   * @param {string} role - The user's role ('client' or 'therapist')\n   * @param {number} limit - Maximum number of conversations to return\n   * @returns {Promise<Array>} - Array of recent conversations\n   */async getRecentConversations(userId,role){let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:5;try{const query=supabase.from('conversations').select(`\n          *,\n          clients:users!conversations_client_id_fkey(*),\n          therapists:users!conversations_therapist_id_fkey(*),\n          summaries(*)\n        `).order('start_ts',{ascending:false}).limit(limit);// Filter by role\nif(role==='client'){query.eq('client_id',userId);}else if(role==='therapist'){query.eq('therapist_id',userId);}const{data,error}=await query;if(error)throw error;return data||[];}catch(error){console.error('Error fetching recent conversations:',error);throw error;}},/**\n   * Update user profile\n   * @param {string} userId - The user's ID\n   * @param {Object} profileData - The profile data to update\n   * @returns {Promise<Object>} - The updated profile\n   */async updateUserProfile(userId,profileData){try{const{data,error}=await supabase.from('users').update(profileData).eq('id',userId).select().single();if(error)throw error;return data;}catch(error){console.error('Error updating user profile:',error);throw error;}},/**\n   * Schedule a session\n   * @param {Object} sessionData - The session data\n   * @returns {Promise<Object>} - The created session\n   */async scheduleSession(sessionData){try{const{data,error}=await supabase.from('sessions').insert([sessionData]).select().single();if(error)throw error;return data;}catch(error){console.error('Error scheduling session:',error);throw error;}}};","map":{"version":3,"names":["supabase","userService","getUserProfile","userId","data","error","from","select","eq","single","console","getClientData","getTherapistData","getTherapistClients","therapistId","order","ascending","clientIds","Set","map","session","client_id","clients","clientsError","in","getUpcomingSessions","role","query","gt","Date","toISOString","getRecentConversations","limit","arguments","length","undefined","updateUserProfile","profileData","update","scheduleSession","sessionData","insert"],"sources":["/Users/gio/development/smartterapist/CascadeProjects/windsurf-project/client/src/services/userService.js"],"sourcesContent":["import { supabase } from './supabaseClient';\n\n/**\n * Service for handling user-related functionality\n */\nexport const userService = {\n  /**\n   * Get user profile data\n   * @param {string} userId - The user's ID\n   * @returns {Promise<Object>} - The user profile data\n   */\n  async getUserProfile(userId) {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error fetching user profile:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get client-specific data\n   * @param {string} userId - The client's user ID\n   * @returns {Promise<Object>} - The client data\n   */\n  async getClientData(userId) {\n    try {\n      const { data, error } = await supabase\n        .from('clients')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error fetching client data:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get therapist-specific data\n   * @param {string} userId - The therapist's user ID\n   * @returns {Promise<Object>} - The therapist data\n   */\n  async getTherapistData(userId) {\n    try {\n      const { data, error } = await supabase\n        .from('therapists')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error fetching therapist data:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get a list of clients for a therapist\n   * @param {string} therapistId - The therapist's user ID\n   * @returns {Promise<Array>} - Array of client data\n   */\n  async getTherapistClients(therapistId) {\n    try {\n      const { data, error } = await supabase\n        .from('sessions')\n        .select('client_id')\n        .eq('therapist_id', therapistId)\n        .order('start_time', { ascending: false });\n        \n      if (error) throw error;\n      \n      // Get unique client IDs\n      const clientIds = [...new Set(data.map(session => session.client_id))];\n      \n      // Get client profiles\n      const { data: clients, error: clientsError } = await supabase\n        .from('users')\n        .select('*, clients(*)')\n        .in('id', clientIds);\n        \n      if (clientsError) throw clientsError;\n      \n      return clients;\n    } catch (error) {\n      console.error('Error fetching therapist clients:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get upcoming sessions for a user\n   * @param {string} userId - The user's ID\n   * @param {string} role - The user's role ('client' or 'therapist')\n   * @returns {Promise<Array>} - Array of upcoming sessions\n   */\n  async getUpcomingSessions(userId, role) {\n    try {\n      const query = supabase\n        .from('sessions')\n        .select(`\n          *,\n          clients:users!sessions_client_id_fkey(*),\n          therapists:users!sessions_therapist_id_fkey(*)\n        `)\n        .gt('start_time', new Date().toISOString())\n        .order('start_time', { ascending: true });\n        \n      // Filter by role\n      if (role === 'client') {\n        query.eq('client_id', userId);\n      } else if (role === 'therapist') {\n        query.eq('therapist_id', userId);\n      }\n      \n      const { data, error } = await query;\n        \n      if (error) throw error;\n      \n      return data || [];\n    } catch (error) {\n      console.error('Error fetching upcoming sessions:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get recent conversations for a user\n   * @param {string} userId - The user's ID\n   * @param {string} role - The user's role ('client' or 'therapist')\n   * @param {number} limit - Maximum number of conversations to return\n   * @returns {Promise<Array>} - Array of recent conversations\n   */\n  async getRecentConversations(userId, role, limit = 5) {\n    try {\n      const query = supabase\n        .from('conversations')\n        .select(`\n          *,\n          clients:users!conversations_client_id_fkey(*),\n          therapists:users!conversations_therapist_id_fkey(*),\n          summaries(*)\n        `)\n        .order('start_ts', { ascending: false })\n        .limit(limit);\n        \n      // Filter by role\n      if (role === 'client') {\n        query.eq('client_id', userId);\n      } else if (role === 'therapist') {\n        query.eq('therapist_id', userId);\n      }\n      \n      const { data, error } = await query;\n        \n      if (error) throw error;\n      \n      return data || [];\n    } catch (error) {\n      console.error('Error fetching recent conversations:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Update user profile\n   * @param {string} userId - The user's ID\n   * @param {Object} profileData - The profile data to update\n   * @returns {Promise<Object>} - The updated profile\n   */\n  async updateUserProfile(userId, profileData) {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .update(profileData)\n        .eq('id', userId)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error updating user profile:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Schedule a session\n   * @param {Object} sessionData - The session data\n   * @returns {Promise<Object>} - The created session\n   */\n  async scheduleSession(sessionData) {\n    try {\n      const { data, error } = await supabase\n        .from('sessions')\n        .insert([sessionData])\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error scheduling session:', error);\n      throw error;\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}